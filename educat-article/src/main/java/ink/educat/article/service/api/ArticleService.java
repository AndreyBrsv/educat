package ink.educat.article.service.api;


import ink.educat.article.dao.api.entities.Article;
import ink.educat.article.dao.api.entities.ShortDetailedArticle;
import ink.educat.user.dao.api.entities.User;

import java.util.List;

/**
 * Сервис для работы со статьями.
 *
 * @discussion При просмотре данного интерфейса может возникнуть вопрос:
 * Зачем нужно делать два класса, которые по сути будут хранить иформацию
 * о статьях? Ответ таков. Когда пользователь заходит в приложение или
 * на сайт, первое, что он перед собой видит - это список статей.
 * Не имеет особого смысла при получении списка статей, тянуть их содержимое,
 * так как загрузив список статей, пользователь может не просмотреть ни одну из
 * них.
 * Напрашивается второй вопрос: Почему в таком случае нельзя сделать один объект
 * и заполнять только те поля, которые необходимы. Ответ тоже тривиальный:
 * из соображения экономии памяти и производительности. Да, в случае сферического
 * коня в вакууме, все и так будет работать нормально. Но, когда нам приходится
 * обрабатывать сотни dto в одно и то же время, то эти dto должны быть как можно
 * более легковесными.
 *
 * @see ink.educat.article.service.impl.ArticleServiceImpl
 * @see ink.educat.article.dao.api.ArticleDao
 *
 */
public interface ArticleService {

    /**
     * Метод, позволяющий получить статью по ее id
     *
     * @param id - уникальный идентификатор статьи
     * @return - возвращет соотвествующую статью, иначе null
     */
    Article getArticleById(long id);

    /**
     * Позволяет получить Json представление статьи по id.
     *
     * @param id - уникальный иденитификатор статьи
     * @return - json прелставление статьи
     */
    String getJsonArticleById(long id);

    /**
     * Метод, позволяющий получить список статей по тегам.
     *
     * @param tags - теги
     * @return - список статей, отвечающих данным тегам
     */
    List<ShortDetailedArticle> getArticleListByTags(String ...tags);

    /**
     * Метод, возвращающий список, возможно, интересных статей для
     * данного пользователя
     *
     * @return - список интересных статей на сервере (да да, именно как раз
     * тут и будет data science, чтобы разобраться, а какая, собственно статья
     * является интересной. Повод подумаьть над системой поиска и рекомендаций)
     */
    List<ShortDetailedArticle> getInterestingArticles();

    /**
     * Метод, возвращающий список, возможно, интересных статей для
     * данного пользователя
     *
     * @param user - пользователь
     * @return - список интересных статей, для данного пользователя
     */
    List<ShortDetailedArticle> getInterestingArticleForUser(User user);

    /**
     * Метод, позволяющий получить список статей, которые были добавлены в
     * закладки пользователем user. Метод возвращает краткую информацию об этих
     * статьях, без содержимого.
     *
     * @param userId - уникальный идентификатор пользователя, для которого осуществляется
     *               поиск добавленных в закладки статей
     * @return - список статей, добавленных в закладки
     *
     * @see ShortDetailedArticle
     *
     */
    List<ShortDetailedArticle> findShortDetailedArticlesBookmarkedByUser(long userId);
}
