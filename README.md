# Educat
Educat -- тьютор сервис.

## Deploy на локальном сервере Jetty

##Добавить конфигурацию Jetty в IntelliJ IDEA

Предварительно нужно установить Jetty сервер на локальную машину, например,
командой:

```bash
brew install jetty
```

В IntellJ IDEA вверху, напротив зеленого молотка есть кнопка Add Configuration.
После нажатия на открывается окно, в этом окне вверху слева нужно нажать "+".
В выпадающем списке выбрать _Jetty_ -> _Local_.

- В появившемся окне в верхнем поле Name вводим имя, например Educat-Jetty.
- В этом же окне уже открыта вкладка Server. В графе Application Server выбираем
наш свежеустановленный Jetty. 
- Остальные настройки в этом окне пока не трограем.
- Внизу над копкой "OK" будет гореть кнопка "Fix" с красной лампочкой.
Нажимаем ее. Idea предлагает создать нам артефакт. Этот артефакт есть ничто иное как
файл *.war, который по нажатию специальной кнопки в maven будет закидываться в папку Jetty
разворачиваться там и запускаться. Так вот, после нажатия кнопки из выпадающего списка
выбрать WebArchive:

-- тут я устал, допишу ее потом

## Соглашения именования и правила написания скриптов

[Отличный видеокурс по базам данных PostgreSQL. Рекомендую смотреть на скорости 1.25x - 1.30x](https://www.youtube.com/watch?v=SfYaAQ9-RnE)

Правда, в некоторых лекциях речь преподавателя расходится со слайдами. Рекомендую открыть слайды по ссылке в описании и листать их параллельно его словам.

**Названия таблиц**

- Новые таблицы создаем с префиксом EC (сокращение от EduCat), потому что если в будущем будем развивать стороние
интеграции, то таблицы будет удобно различать по префиксу.

- Если таблица хранит модельные сущности, например пользователей, то не забываем добавлять множественное число. То есть, 
если храним в таблице пользователей, то название таблицы не USER, а USERS

```sql
CREATE TABLE EC_USERS ( 

... 

);
```

- Если это таблица, например, отвечает за хранение заданий, выполненных пользователями,
то множественное число добавляется к последнему слову в назвавнии таблицы

не

```sql
EC_USERS_COMPLETE_TASKS
```

а

```sql
EC_USER_COMPLETE_TASKS
```

**Название суррогатного ключа**

Название суррогатного ключа(часто именно он объявляется как *PRIMARY KEY*) строится так: опускаем префикс таблицы, убираем множественно число и добавляем _ID в конец:

```sql
для EC_USERS -> USER_ID, 
для EC_USER_COMPLETE_TASKS -> USER_COMPLETE_TASK_ID
```
**Название внешнего ключа**

Как правило, если какой-то из столбцов ссылается на другую таблицу, то он ссылается на *PRIMARY_KEY* этой таблицы. Название колонки ссылающейся таблицы должно совпадать с названием колонки той таблицы на которую ссылаются. То есть если таблица
EC_USER_COMPLETE_TASKS должна ссылаться на первичный ключ таблицы EC_USERS, то название этой колонки должно совпадать с названием первичного ключа, а именно USER_ID.

Таким образом таблица EC_USER_COMPLETE_TASKS потенциально может иметь вид:

USER_COMPLETE_TASK_ID | USER_ID | TASK_ID | ...
----------------------|---------|---------| ---
555 | 22 | 9 | ... 
551 | 125| 13| ...
... |... |...| ...


**Последовательности и триггеры**

Последовавтельности (sequences) в базах данных нужны для генерации, как ни странно, последовательности чисел с заранее
заданными параметрами. Ну например, нам нужно чтобы при вставке записи в таблицу, значение суррогатного ключа генерировалось
автоматически. Тут на помощь нам приходят последовательности (и триггеры). О них мы поговорим ниже.

Именование последовательности происходит с добавлением префикса SEQ, таким образом для таблицы EC_USERS:

```sql
CREATE SEQUENCE SEQ_EC_USERS 
...
;
```

Перейдем к триггерам. Триггеры - это такие блоки кода в БД, которые срабатывают при выполнении каких-нибудь действий с базой.
Самые часто используемые триггеры - это триггеры, срабатывающие до вставки строк(и) в таблицу (BEFORE INSERT OR UPDATE TRIGGER), и, срабатывающие после вставки в таблицу (AFTER INSERT OR UPDADTE TRIGGER).

Рассмотрим пример. Допустим, мы реализуем возможность организации подписок пользователей друг на друга. Мы создаем следующую таблицу:

```sql
CREATE TABLE EC_USER_TO_USER_SUBSCRIPTIONS
(
    SUBSCRIBE_USER_ID  INTEGER NOT NULL,
    SUBSCRIBED_USER_ID INTEGER NOT NULL,
    PRIMARY KEY (SUBSCRIBE_USER_ID, SUBSCRIBED_USER_ID)
);
```
, где SUBSCRIBE_USER_ID - пользователь, на которого была осуществлена подписка, SUBSCRIBED_USER_ID - пользователь, который подписался. 

В данном случае может возникнуть ситуация, когда пользователь подписан сам на себя. Нужно эту ситуацию исключить. Это можно сделать при помощи триггера, который будет проверять данные записи перед вставкой в таблицу.

Правила именования триггеров такие: TRG_Название_таблицы_Название_действия и постфикс _BI/AI (в зависимости от того, когда происходит действие триггера Before Insert или After Insert).

Для начала напишем процедуру проверки полей, не акцентируем на синтаксисе внимание, так как основная тема именоване триггера:

```sql
CREATE FUNCTION CHECK_SUBSCRIBERS_ID() RETURNS TRIGGER AS
$EC_TRG_ADD_NEW_SUBSCRIBER_BI$
BEGIN
    IF NEW.SUBSCRIBE_USER_ID = NEW.SUBSCRIBED_USER_ID THEN
        RAISE EXCEPTION $$SUBSCRIBE_USER_ID and SUBSCRIBED_USER_ID can't be equal$$;
    END IF;
    RETURN NEW;
END;
$EC_TRG_ADD_NEW_SUBSCRIBER_BI$ LANGUAGE plpgsql;
```

и сам триггер:

```sql
CREATE TRIGGER TRG_EC_USER_TO_USER_SUBSCRIPTIONS_CHECK_USER_IDS_BI
    BEFORE INSERT OR UPDATE
    ON EC_USER_TO_USER_SUBSCRIPTIONS
    FOR EACH ROW
EXECUTE PROCEDURE CHECK_SUBSCRIBERS_ID();
```
таким образом из названия видно: 
1) это триггер(по префиксу); 
2) название таблицы, к которой он привязан;
3) действие, которое он выполняет;
3) момент выполнения действия;


**Индексы**

- Для создания уникального индекса нужно использовавть префикс UI_ (сокр. unique index): UI_НазваниеТаблицы_Колонка1_Колонка2_... 
Например, для таблицы EC_USERS создание уникального индекса на колонку EMAIL выглядит так:

```sql
CREATE UNIQUE INDEX UI_EC_EDUCAT_EMAIL ON EC_USERS (EMAIL);
```

- Создание неуникального индекса выглядит аналогично, но с другим префиксом: вместо UI_ пишем NUI_ (сокр. non unique index).
Например, неуникальный индекс по статусам пользователей:

```sql
CREATE INDEX NUI_EC_EDUCAT_STATUS ON EC_USERS (STATUS);
```

**Комментарии**

Обязательно добавлять для всех таблиц и их колонок комментарии.

Для колонки:

```sql
COMMENT ON COLUMN EC_USERS.USER_ID IS 'Id пользователя';
```

Для таблицы:

```sql
COMMENT ON TABLE EC_USERS IS 'Пользователи';
```

