# Educat
Educat -- тьютор сервис.

## Deploy на локальном сервере Jetty

##Добавить конфигурацию Jetty в IntelliJ IDEA

Предварительно нужно установить Jetty сервер на локальную машину, например,
командой:

```bash
brew install jetty
```

В IntellJ IDEA вверху, напротив зеленого молотка есть кнопка Add Configuration.
После нажатия на открывается окно, в этом окне вверху слева нужно нажать "+".
В выпадающем списке выбрать _Jetty_ -> _Local_.

- В появившемся окне в верхнем поле Name вводим имя, например Educat-Jetty.
- В этом же окне уже открыта вкладка Server. В графе Application Server выбираем
наш свежеустановленный Jetty. 
- Остальные настройки в этом окне пока не трограем.
- Внизу над копкой "OK" будет гореть кнопка "Fix" с красной лампочкой.
Нажимаем ее. Idea предлагает создать нам артефакт. Этот артефакт есть ничто иное как
файл *.war, который по нажатию специальной кнопки в maven будет закидываться в папку Jetty
разворачиваться там и запускаться. Так вот, после нажатия кнопки из выпадающего списка
выбрать WebArchive:

-- тут я устал, допишу ее потом

## Соглашения именования скриптов

**Названия таблиц**

- Новые таблицы создаем с префиксом EC (сокращение от EduCat), потому что если в будущем будем развивать стороние
интеграции, то таблицы будет удобно различать по префиксу.

- Если таблица хранит модельные сущности, например пользователей, то не забываем добавлять множественное число. То есть, 
если храним в таблице пользователей, то название таблицы не USER, а USERS

```sql
CREATE TABLE EC_USERS ( 

... 

);
```

- Если это таблица, например, отвечает за хранение заданий, выполненных пользователями,
то множественное число добавляется к последнему слову в назвавнии таблицы

не
```sql
EC_USERS_COMPLETE_TASKS
```

а
```sql
EC_USER_COMPLETE_TASKS
```

**Название суррогатного ключа**

Название суррогатного ключа(часто именно он объявляется как *PRIMARY KEY*) строится так: опускаем префикс таблицы, убираем множественно число и добавляем _ID в конец:

```sql
для EC_USERS -> USER_ID, 
для EC_USER_COMPLETE_TASKS -> USER_COMPLETE_TASK_ID
```
**Название внешнего ключа**

Как правило, если какой-то из столбцов ссылается на другую таблицу, то он ссылается на *PRIMARY_KEY* этой таблицы. Название колонки ссылающейся таблицы должно совпадать с названием колонки той таблицы на которую ссылаются. То есть если таблица
EC_USER_COMPLETE_TASKS должна ссылаться на первичный ключ таблицы EC_USERS, то название этой колонки должно совпадать с названием первичного ключа, а именно USER_ID.

Таким образом таблицы EC_USER_COMPLETE_TASKS потенциально может иметь вид:

USER_COMPLETE_TASK_ID | USER_ID | TASK_ID | ...
----------------------|---------|---------| ---
555 | 22 | 9 | ... 
551 | 125| 13| ...
... |... |...| ...


**Последовательности и триггеры**

Последовавтельности (sequences) в базах данных нужны для генерации, как ни странно, последовательности чисел с заранее
заданными параметрами. Ну например, нам нужно чтобы при вставке записи в таблицу, значение суррогатного ключа генерировалось
автоматически. Тут на помощь нам приходят последовательности и, в частности, триггеры. О них мы поговорим ниже.

Именование последовательности происходит с добавлением префикса SEQ, таким образом для таблицы EC_USERS:
```sql
CREATE SEQUENCE SEQ_EC_USERS 
...
;
```

**Индексы**

**Комментарии**

Обязательно добавлять для всех таблиц и их колонок комментарии.

Для колонки:
```sql
COMMENT ON COLUMN EC_USERS.USER_ID IS 'Id пользователя';
```

Для таблицы:
```sql
COMMENT ON TABLE EC_USERS IS 'Пользователи';
```

